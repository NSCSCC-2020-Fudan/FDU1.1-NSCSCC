# wrap your top module & expand all struct ports
# dump: parse XML files generated by verilator to .top files.
# parse: generate top module SystemVerilog files from .top files.
#
# NOTE: "_x_" is reserved for this script. DO NOT USE DOUBLE UNDERLINES
#       IN YOUR RTL DESIGNS.
#       dots in hierarchical references will be replace by "_x_"
#
# Usage:
#   python wrap.py dump build/VOneLineBuffer.xml > build/VOneLineBuffer.top
#   cat build/oneline.top build/VOneLineBuffer.top | python wrap.py parse > build/top.sv
#
# Port Specification: write ports in "ports" section.
#   [port name]: [reference listed in "available" section]
#
# Remark:
#   MAKES THE ************* VERILATOR GREAT AGAIN?

SEP = '_x_'

from typing import Text, List, Dict, Iterator, Optional

import sys
import click
import textwrap

from dataclasses import dataclass
from xml.etree import ElementTree

TFilePath = click.Path(exists=True, file_okay=True, dir_okay=False, readable=True)


def warn(message):
    sys.stderr.write(f'(warn) {message}\n')

# Python 3.9
def removeprefix(s: Text, prefix: Text) -> Text:
    if s.startswith(prefix):
        return s[len(prefix):]
    else:
        return s[:]

def parse_hex(s: Text) -> int:
    if s.startswith('32\'h'):
        return int(s[4:], base=16)
    elif s.startswith('32\'sh'):
        return int(s[5:], base=16)
    else:
        raise ValueError(s)


@click.group()
def cli():
    pass


@dataclass
class Block:
    title: Text
    lines: List[Text]

@dataclass
class StructMember:
    name: Text
    type_ref: Text

@dataclass
class Struct:
    name: Text
    decl: Text
    members: List[StructMember]

@dataclass
class PackedArray:
    idx: Text
    hi: Text
    lo: Text
    type_ref: Text

@dataclass
class Variable:
    name: Text
    type_ref: Text

@dataclass
class Port:
    name: Text
    type_ref: Text
    direction: Text

@dataclass
class Instance:
    name: Text
    modname: Text

@dataclass
class Module:
    name: Text
    ports: List[Port]
    variables: List[Variable]
    instances: List[Instance]

@dataclass
class Reference:
    type_name: Text
    reference: Text


def print_document(doc: List[Block]):
    for block in doc:
        print(f'# {block.title}')
        for line in block.lines:
            print(line)
        print('')  # empty line


@cli.command(short_help='Dump the ports description file.')
@click.argument('path', type=TFilePath)
def dump(path: Text):
    tree = ElementTree.parse(path)
    root = tree.getroot()

    includes = Block('includes', [])
    top_ports = Block('top', [])
    avail = Block('available', [])
    doc: List[Block] = [includes, top_ports, avail]

    # pass 1: dump type list & includes
    files = root.find('files')
    assert files is not None
    for u in files:
        filename = u.get('filename')
        assert filename is not None
        if filename.endswith('.svh'):
            includes.lines.append(filename)

    type_table = root.find('netlist/typetable')
    assert type_table is not None

    type_mp: Dict[Text, Text] = {}
    structs: List[Struct] = []
    arrays: List[PackedArray] = []
    for t in type_table:
        idx = t.get('id')
        assert idx is not None

        if t.tag == 'basicdtype':
            name = t.get('name')
            left = t.get('left', default='0')
            right = t.get('right', default='0')
            assert name is not None
            type_mp[idx] = (name if left == right or name != 'logic'
                else f'{name}[{left}:{right}]')
        elif t.tag == 'refdtype' or t.tag == 'paramtypedtype':
            name = t.get('name')
            assert name is not None
            type_mp[idx] = name
        elif t.tag == 'uniondtype':
            name = t.get('name', default=f'{SEP}union_{idx}')
            assert name is not None
            name = removeprefix(name, '$unit::').replace('.', SEP)
            type_mp[idx] = name

            struct = Struct(f'union:{name}', '', [
                StructMember(
                    v.get('name', default='*'),
                    v.get('sub_dtype_id', default='*')
                )
                for v in t
                if v.tag == 'memberdtype'
            ])
            structs.append(struct)
        elif t.tag == 'structdtype':
            name = t.get('name', default=f'{SEP}struct_{idx}')
            assert name is not None
            name = removeprefix(name, '$unit::').replace('.', SEP)
            type_mp[idx] = name

            struct = Struct(f'struct:{name}', '', [
                StructMember(
                    v.get('name', default='*'),
                    v.get('sub_dtype_id', default='*')
                )
                for v in t
                if v.tag == 'memberdtype'
            ])
            structs.append(struct)
        elif t.tag == 'packarraydtype':
            type_mp[idx] = ''  # to be filled
            type_ref = t.get('sub_dtype_id')
            assert type_ref is not None
            hi, lo = list(map(
                lambda x: str(parse_hex(str(x.get('name')))),
                t.findall('range/const')
            ))

            arrays.append(PackedArray(idx, hi, lo, type_ref))
        elif t.tag == 'enumdtype':
            name = t.get('name', default=f'{SEP}enum_{idx}')
            assert name is not None
            type_mp[idx] = name
        else:
            warn(f'Unsupported type: "{t.tag}"')

    # pass 2: review packed arrays, dump structs/unions
    # replace dot to SEP
    for key, value in type_mp.items():
        type_mp[key] = value.replace('.', SEP)

    for array in arrays:
        type_name = type_mp[array.type_ref]
        type_mp[array.idx] = f'{type_name}[{array.hi}:{array.lo}]'

    for struct in structs:
        blk = Block(struct.name, [
            f'{type_mp[member.type_ref]} {member.name}'
            for member in struct.members
        ])
        doc.append(blk)

    # pass 3: dump modules
    netlist = root.find('netlist')
    assert netlist is not None

    top = None
    module_mp: Dict[Text, Module] = {}
    for t in netlist:
        if t.tag != 'module':
            continue

        name = t.get('name')
        is_top = t.get('topModule')
        assert name is not None
        if is_top == '1':
            top = name

        m = Module(name, [], [], [])

        for u in t:
            if u.tag == 'var':
                vname = u.get('name')
                type_ref = u.get('dtype_id')
                assert vname is not None
                assert type_ref is not None

                direction = u.get('dir')
                if direction is not None:
                    m.ports.append(Port(
                        vname, type_ref, direction
                    ))
                else:
                    m.variables.append(Variable(
                        vname, type_ref
                    ))
            elif u.tag == 'instance':
                iname = u.get('name')
                modname = u.get('defName')
                assert iname is not None
                assert modname is not None

                m.instances.append(Instance(
                    iname, modname
                ))

        module_mp[name] = m

    # pass 4: generate references
    def dfs(m: Module, prefix: Text) -> Iterator[Reference]:
        for port in m.ports:
            type_name = type_mp[port.type_ref]
            yield Reference(type_name, f'{prefix}{port.name}')
        for variable in m.variables:
            type_name = type_mp[variable.type_ref]
            yield Reference(type_name, f'{prefix}{variable.name}')

        for instance in m.instances:
            submodule = module_mp[instance.modname]
            yield from dfs(submodule, f'{prefix}{instance.name}.')

    top_module = next(iter(module_mp.values())) if top is None else module_mp[top]
    top_ports.title = f'top:{top_module.name}'
    for port in top_module.ports:
        top_ports.lines.append(
            f'{port.direction} {type_mp[port.type_ref]} {port.name}'
        )

    for ref in sorted(dfs(top_module, ''), key=lambda x: x.reference):
        avail.lines.append(f'{ref.type_name} {ref.reference}')

    print_document(doc)


@dataclass
class Assign:
    referer: Text  # port name
    referee: Text  # target variable/reference


@cli.command(short_help='Generate top module.')
@click.option('--name', type=str, default='Device')
def parse(name: Text):
    # scan top file
    section: Optional[Text] = None
    tag: Optional[Text] = None

    includes: List[Text] = []
    typedefs: List[Text] = []
    structs: Dict[Text, Struct] = {}
    ref_type: Dict[Text, Text] = {}
    ports: List[Port] = []
    assigns: List[Assign] = []
    cur_struct_name: Optional[Text] = None
    top_module = None

    for line in sys.stdin:
        line = line.strip()
        if len(line) == 0 or line.startswith('//'):
            continue

        if line.startswith('#'):
            section = line[1:].strip()
            if ':' in section:
                section, tag = section.split(':', maxsplit=1)
            else:
                tag = None

            if section == 'top':
                top_module = tag
            elif section in ['struct', 'union']:
                assert tag is not None
                structs[tag] = Struct(tag, section, [])
                cur_struct_name = tag
            else:
                cur_struct_name = None
        else:
            assert section is not None
            if section  == 'ports':
                port_name, reference = line.split(':', maxsplit=1)
                assigns.append(Assign(port_name.strip(), reference.strip()))
            elif section == 'top':
                direction, type_name, port_name = line.split(' ')
                ports.append(Port(port_name, type_name, direction))
            elif section == 'available':
                type_name, reference = line.split(maxsplit=1)
                ref_type[reference.strip()] = type_name.strip()
            elif section == 'includes':
                includes.append(line)
            elif section in ['struct', 'union']:
                assert cur_struct_name is not None
                type_name, member_name = line.split(maxsplit=1)
                member = StructMember(member_name.strip(), type_name.strip())
                structs[cur_struct_name].members.append(member)

    # dump typedefs
    for struct in structs.values():
        if SEP in struct.name:
            typedefs.append(
                f'typedef {struct.decl} packed {{\n' +
                textwrap.indent('\n'.join(
                    f'{member.type_ref} {member.name};'
                    for member in struct.members
                ), ' ' * 4) +
                f'\n}} {struct.name};'
            )

    # dump assign ports
    for obj in assigns:
        ports.append(Port(obj.referer, ref_type[obj.referee], 'output'))
        obj.referee = f'{SEP}top.{obj.referee}'

    # expand struct ports
    for port in ports:  # incrimental expansion
        if port.type_ref not in structs:
            continue

        struct = structs[port.type_ref]
        for member in struct.members:
            new_name = f'{port.name}{SEP}{member.name}'
            ports.append(Port(
                new_name,member.type_ref, 'output'
            ))
            assigns.append(Assign(new_name, f'{port.name}.{member.name}'))

    # generate top module source code
    print('// This file is automatically generated.\n')
    print('\n'.join(
        f'`include "{filename}"'
        for filename in includes
    ))
    print('')
    if len(typedefs) > 0:
        print('\n\n'.join(typedefs))
        print('')
    print(f'module {name}Top (')
    print(textwrap.indent(',\n'.join(
        f'{port.direction} {port.type_ref} {port.name}'
        for port in ports
    ), ' ' * 4))
    print(');')
    print(f'    {top_module} {SEP}top(.*);')
    if len(assigns) > 0:
        print(textwrap.indent(
            '\n'.join(
                f'assign {assign.referer} = {assign.referee};'
                for assign in assigns
            )
            ,  ' ' * 4
        ))
    print('endmodule')


if __name__ == '__main__':
    cli()